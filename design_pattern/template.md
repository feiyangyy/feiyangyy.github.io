## 何为设计模式
简单来说，就是识别业务中的**变与不变**的部分，并将不变的部分通过一定的方法固定下来，以实现代码复用。这些方法我们就可以统称为设计模式

可见，应用设计模式的前提是业务之中要存在变与不变的部分，如果一个项目就没有稳定的部分（比如做完就丢的一次性项目），那么应用设计模式就是浪费时间。如果一个项目全是不变的部分，业务是确定的，那么就没必要引入设计模式

第二点是，应用设计模式之前要对业务有正确的认识，以采取适当的策略；这也是重构和原型制作的合理性所在。 在某些语言社区，在开展实际代码之前上来就是一套设计模式组合拳，我认为这是很危险的浪费时间的行为

设计模式的类型可以划分成：
1. 结构型: 减少变化对既有代码的冲击，即增强代码的结构稳定性
2. 创建型: 创建复杂对象
3. 行为型: 通过类之间的集成和组合划分职责，缩小变化影响的范围

## Template method 

Template method 是指有A类（的对象，以后同）定义算法框架，由B类实现部分或者全部细节， 宽泛的说，这里的A类、B类，不一定有继承关系。

```C++
class A {
  public:
  //  省略 样板代码
  // ...
  // 

  // 算法
  void run() {
    // A 提供的函数，作为前置
    Step0();
    // 调用细节，不同的类可能发生变化 
    Step1();
    // 调用细节，不同的类可能发生变化 
    Step2();
    
    // A 提供的函数，作为后置
    Step3();

  }
  protected:
  virtual void Step1();
  virtual void Step2();
};

class B : public A {
  // 忽略样板代码
  protected:
  virtual void Step1() override {
    // sth
  }
  virtual void Step2() override {
    // sth
  }
};
```

这个例子中，Step0,Step3, 是业务的固定部分，并且整个算法骨架是Step0-3; 而子类B则 提供了step1 2的细节。 这个例子中A、B是有继承关系的，然后这里的Step1 Step2 完全可以用回调或者std::function 代替，使得B A解除继承关系。 通常来说，除非明确是is-a的情况下，我们不建议使用继承

这个例子很好的体现了设计模式的基本思想：
1. 变与不变：A中的算法骨架是不变的， step1 step2 的实现是变化的
2. 业务变化，只需要增加或者修改一个A的子类即可，不会扩算到A中
3. 依赖后置：在撰写A时已经确定算法骨架，此时B可能尚未开发，这里B的开发有了A的指引就会更明确。 

这里的依赖后置，运行我们有运行时的切换行为，比如 另外一个类C实现不同的业务，我们可以通过控制生成不同的对象来完成这个需求（典型的多态）。 这似乎是一种必须，如果是依赖前置的话，则意味着B、C的实现中都需要包含A，这部分代码，就是重复的了，另外如何在更高层次的代码中兼容这些类型，也是个问题。