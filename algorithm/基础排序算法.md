# 基础排序算法

## 基础排序
### 选择排序
核心思想是每次选择最小的，放到最前方，算法复杂度O(n^2) ($$\sum_{i=1}^{n-1}i$$)

[参考实现](https://github.com/feiyangyy/naive_codes/blob/dd568a3c29d66e4719377cb6f779394101bb0997/algorithm/basic_sort.cc#L27)

### 插入排序
1. 将序列分为左右两个部分，左侧有序，右侧未处理
2. 选择右侧第一个元素，在左侧有序部分寻找插入位置
    * 移动序列，腾出插入位置
    * 插入元素，左侧数量+1， 右侧-1
    * **寻找插入位置时，应当是从后往前找**， 从前往后找，判断会稍微复杂且无必要
3. 重复2，直到右侧序列处理完毕

[参考实现](https://github.com/feiyangyy/naive_codes/blob/dd568a3c29d66e4719377cb6f779394101bb0997/algorithm/basic_sort.cc#L48)

插排性能消耗主要是:
1.  元素比较，逆序的元素越多，要比较的次数越多
2.  元素移动，逆序的元素越多，要移动的子序列也就越长

### 希尔排序
希尔排序似乎是个理论上不太好分析的排序

总体思想是，不长从大到小，逐步把序列排成有序的状态

1. 先划分step, step不能超过序列大小， step的划分可以通过算法自动生成
2. 按照每个step 进行插入排序，随着step 缩小，序列有序的程度逐步增加
3. 当step=1时， 即等价于使用插入排序， 但此时序列已相当有序，效率会比插排要高

希尔排序的性能存在一定随机性

[参考实现](https://github.com/feiyangyy/naive_codes/blob/dd568a3c29d66e4719377cb6f779394101bb0997/algorithm/basic_sort.cc#L102)
