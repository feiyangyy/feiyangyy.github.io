## 进程和线程

### 物理内存和虚拟内存
应用程序直接使用物理内存的三个问题：
1. 安全和健壮性问题，恶意读写别的进程的内存
2. 内存管理效率问题， 100M内存，10M A 80M B， 如果需要20M的C，则需要把B换到磁盘上，整个磁盘换入换出操作成本很高
3. 每次加载的起始地址不同，导致程序使用的变量、函数等需要**重定位**

1. 3. 通过虚拟内存解决，即每个进程有自己的地址空间，并且，起始都从0或者某个固定偏移开始。别的进程不能访问本进程的内存空间

2. 通过页管理解决，页管理将物理内存分成固定大小的页，每个页都有一个页表项，页表项包含页的物理地址。当进程访问虚拟内存时，虚拟内存会根据页表项，将虚拟地址转换为物理地址。如果物理内存不足，页管理会将不常用的页换出到磁盘上，然后将需要的页换入到物理内存中。

页可以简单分为：
1. 虚拟内存页 VP: application 中使用的虚拟内存分页，可能位于磁盘上
2. 物理内存页 PP: 物理内存中的页
3. 磁盘页 DP：被换到磁盘上的页

页除了划分管理单元之外，还有一些读写保护属性，以支持实现1. 3.

虚拟地址到物理地址的转换通常由MMU完成。

这个中间需要有一个缓存机制控制页的换入换出，比如，内存不足时，需要根据一个缓存策略将不常用的页换出到磁盘上，并载入需要载入的页

### 线程和进程
windows 实现和教科书差不多，linux实现是一个个task, 每个task就是一个执行单元，并且一组task 可以选择共享内存地址（文件描述符等）从而形成一个进程

线程私有的东西：
1. 栈
2. 寄存器组
3. PC（指令寄存器）
4. 某些OS分配的TLS

线程共享的东西：
1. 虚拟地址空间：全局变量、静态变量、堆
2. 文件描述符、信号

线程的状态：
1. Ready (可运行尚未被运行)
2. Running 
3. Pending (一些IO Block或者锁Block)

Folk写时复制是指？调用了fork系统调用过后可以嗯可以创建一个把当前进程的一个镜像啊，或者副本。然后当任何一个嗯任何一者修改的内存中的数据，那么他就会把这一个内存复制一份，然后提供给这个。对方使用这个就是所谓的写时复制。
